# Static Analysis

Static analysis of a malware artifact depends on the type of `file` being analyzed.

Reverse-engineering a malware sample helps understand its functionality, origin, impact, and potential development of patches (e.g., recovering ransomware-encrypted files).

## Tooling

- **Decompilers:** tools to reconstruct the higher-level programming language (e.g., C, Python, Java) from a given executable. 
- **Disassemblers:** tools to translate machine code from the binary to a human-readable assembly instructions.

## Examples

- Popular tooling for disassembly/decompilation of
  - **Linux executable binaries (ELF files):** GDB, Ghidra, IDA, and Radare2
  - **Microsoft .NET executables:** JetBrains DotPeek or the open-source alternative ILSpy
  - **Java-based artifacts (JAR, APK, Kotlin Bytecode)**: Java Decompiler

## Practice

1. Create `main.c`

   ```c
   #include<stdio.h>
   int main() {
       printf("Hello World!");
       return 0;
   }
   ```

1. Compile with debugging symbols

   ```bash
   gcc main.c
   ```

1. Disassemble with GDB

   ```bash
   gdb -q a.out
   > disas main 
   ```

## Exercise 3

- The malware from exercise 1 is a simple VBScript; No need for special tools to read the source code!
- Inspect `suspecious.vbs` with a text editor like `nano`: explain the overall behavior of the malware then answer the questions by showing relevant lines from the source code:
  - How does the malware override browser homepage?
  - Which registry values are being updated and why?
  - Where does the malware copies itself?

